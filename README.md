# Компилятор в X86 Assembly/GAS
Проект был выполнен Хованским В. в рамках курса по технологиям и инструментам построения языковых процессоров кафедры «Компьютерных технологий» Университета ИТМО.

## Синтаксис и сементика языка
1. **Арифметически выражения** любой вложенности
с выполнением в соответствии с уровнями старшенства
    1. `*`, `/`, `%`
    2. `+`, `-`
2. **Логические выражения** любой вложенности
с выполнением в соответствии с уровнями старшенства
и операторы сравнения и проверки равенства
    1. `==`, `!=`, `>`, `>=`, `<`, `<=`
    2. `&&`
    3. `||`, `!!`
3. **Переменые** 
    1. `x := 5 * y`
    2. `z := x <= y`
4. **Операции ввода-вывода** (ввод и вывод осуществляется в стандартные потоки ввода и вывода: stdin, stdout)
    1. `x := read()`
    2. `write(x)`
5. **Условия** с альтернативным ветками (как конкретными, так и обобщенными)
    ```
    if x >= y && z then
        write(x)
    elif z == 0 then
        write(y)
    else
        write(z) fi   
    ```
6. **Циклы while**
    ```
    while k > 0
    do
        res := res * n;
        k := k - 1
    od;
    ```
7. **Циклы for** с поддержкой составных условий и skip в предусловии
    ```
    for c := 2, c * c <= p && f, c := c + 1
    do
        f := p % c != 0
    od;
    ```
    ```
    for skip, n >= 1, n := n-1
    do
        f := f * n
    od;
    ```
8. **Фукнции**
    ```
    fun A (m, n)
    begin
        if m == 0 then return n+1
        elif m > 0 && n == 0 then return A (m-1, 1)
        else return A (m-1, A(m, n-1))
        fi
    end
    
    write (A (1, 21))
    ```
    
9. **Символы**
    1. `C := 'a'`

10. **Строки** и набор предопределенных функций для работы с ними:<br />
    `S := "I will remember April."`
    1. **strlen** - получение длины строки:<br />
        `strlen(S)` => `22`
    2. **strget** - получение заданного символа строки:<br />
        `strget(S, 2)` => `w`
    3. **strsub** - получение подстроки, начиная с символа n, длиной в k символов:<br />
        `strsub (S, 7, 8)` => `remember`
    4. **strdup** - копирование строки:<br />
        `strdup(S)` => `I will remember April.`,
    5. **strset** - задание i-го символа строки:<br />
        `strset(S, 4, 'j')` => `I wijl remember April.`,
    6. **strcat** - конкатенация двух строк:<br />
        `strcat(S, " It was very cold.")` => `I will remember April. It was very cold.`,
    7. **strcmp** - сравнение двух строк (сравнение осуществляется по кодам символов строк, слева направо):<br />
        `strcmp(S, "I wijl remember April.")` => `1`<br />
        `strcmp(S, "I wiz")` => `-1`<br />
        `strcmp(S, "I will")` => `-1`<br />
        `strcmp(S, "I will remember April.")` => `0`
    8. **strmake** - создание строки из n повторящихся символов:<br />
        `strmake (10, 'a')` => `aaaaaaaaaa`

11. **Массивы значений** (unboxed-массивы) и набор предопределенных функций для работы с ними:<br />
    1. **arrmake** - создание массива:<br />
        1. `S := arrmake (5, 0)` => `[0, 0, 0, 0, 0]`
        2. `S := arrmake (5, 123)` => `[123, 123, 123, 123, 123]`
    2. **arrlen** - получение длины массивы:<br />
        `arrlen(S)` => `5`
    4. Присвоение значения элементу массива по индексу:<br />
        `S[1] := 4` => `[0, 4, 0, 0, 0]`
    5. Получение значения элемента массива по индексу:<br /> 
        `write(S[1])` => `4`

12. **Массивы ссылок** (boxed-массивы), набор предопределенных функций для работы с ними, а также сборщик мусора (GC):<br />
    1. **Arrmake** - создание массива:<br />
        1. `S := Arrmake (5, {})` => `[nullptr, nullptr, nullptr, nullptr, nullptr]`
        2. Присвоение со значением по умолчанию:<br />
            1. `S1 := arrmake (2, 1)` => `[1, 1]`
            2. `S2 := arrmake (2, 3)` => `[3, 3]`
            3. `S := Arrmake (2, {})`
            4. `S[0] = S1`
            5. `S[1] = S2`
            6. `S2[1] := 4`
            7. `write(S[0][1])` => `1`
            8. `write(S[1][0])` => `3`
            9. `write(S[1][1])` => `4`
    2. **arrlen** - получение длины массивы:<br />
        `arrlen(S)` => `5`
    3. Присвоение ссылки элементу массива по индексу:<br />
        `S[1] := S1` => `[1, 1]`
    4. Получение значения элемента массива по индексу:<br /> 
        `write(S[1][0])` => `1`
